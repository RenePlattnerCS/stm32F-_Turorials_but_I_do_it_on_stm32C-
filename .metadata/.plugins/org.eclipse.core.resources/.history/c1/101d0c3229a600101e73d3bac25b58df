#include "spi.h"

#define SPI1EN			(1U << 12)
#define GPIOAEN			(1U << 0)
#define GPIOBEN			(1U << 1)

#define SPI_CPOL		(1U << 1)
#define SPI_CPHA		(1U<< 0)
#define SPI_FULL_DUPLEX (1U << 10)
#define SPI_MASTER		(1U << 2)

#define SPI_RXNE	(1U << 0)
#define SPI_TXE		(1U << 1)
#define SPI_BUSY	(1U << 7)

//cs    PB0

//SCK   PA5
//MISO  PA6
//MOSI  PA7
//AF0
void spi_gpio_init(void)
{

	RCC->IOPENR |= GPIOAEN;
	RCC->IOPENR |= GPIOBEN;


	//AF0
	GPIOA->MODER &= ~(1U<<10);
	GPIOA->MODER |= (1U<<11);

	GPIOA->MODER &= ~(1U<<12);
	GPIOA->MODER |= (1U<<13);

	GPIOA->MODER &= ~(1U<<14);
	GPIOA->MODER |= (1U<<15);


	//cs output pin
	GPIOB->MODER &= ~(3U << 0);
	GPIOB->MODER |= (1U << 0);

	GPIOA->AFR[0] &= ~(0xF << (5 * 4));  // Clear AF for PA5
	GPIOA->AFR[0] |= (0x0 << (5 * 4));   // AF0

	GPIOA->AFR[0] &= ~(0xF << (6 * 4));  // Clear AF for PA6
	GPIOA->AFR[0] |= (0x0 << (6 * 4));   // AF0

	GPIOA->AFR[0] &= ~(0xF << (7 * 4));  // Clear AF for PA7
	GPIOA->AFR[0] |= (0x0 << (7 * 4));   // AF0

	// Set CS high initially (idle state)
	GPIOB->ODR |= (1U << 0);



}

void spi1_config(void)
{
	RCC->APBENR2 |= SPI1EN;
	// Disable SPI before configuration
	SPI1->CR1 &= ~(1U << 6);


	// For 48MHz, BR = 011 gives 48MHz/16 = 3MHz (safe for ADXL345)
	SPI1->CR1 &= ~(7U << 3);  // Clear BR bits
	SPI1->CR1 |= (3U << 3);   // BR = 011 (divide by 16)

	SPI1->CR1 |= SPI_CPOL;
	SPI1->CR1 |= SPI_CPHA;

	//SPI1->CR1 &= ~SPI_FULL_DUPLEX;

	//MSB first
	SPI1->CR1 &= ~ (1U << 7);

	SPI1->CR1 |= SPI_MASTER;


	//internal slave select
	SPI1->CR1 |= (1U << 8);
	SPI1->CR1 |= (1U << 9);

	// Full-duplex mode (BIDIMODE = 0, RXONLY = 0)
	SPI1->CR1 &= ~(1U << 15);  // Clear BIDIMODE (full duplex)
	SPI1->CR1 &= ~(1U << 10);  // Clear RXONLY



	// Configure data size to 8-bit (DS[3:0] = 0111)
	SPI1->CR2 &= ~(0xF << 8);   // Clear DS bits
	SPI1->CR2 |= (0x7 << 8);    // DS = 0111 for 8-bit

	// Set FRXTH for 8-bit mode (FIFO threshold)
	SPI1->CR2 |= (1U << 12);    // FRXTH = 1 for 8-bit

	//peripheral enable
	SPI1->CR1 |= (1U << 6);


}

void spi1_transmit(uint8_t *data, uint32_t size)
{
	uint32_t i=0;
	uint8_t temp;

	while(i<size)
	{
		//wait for TXE
		while(!(SPI1->SR & SPI_TXE)){}

		//write data to data reg
		SPI1->DR = data[i];
		i++;
	}

	//wait again for TXE
	while(!(SPI1->SR & SPI_TXE)){}
	//wait for busy
	while((SPI1->SR & SPI_BUSY)){}

	// Wait until RXNE


	//clear overrun flag
	temp = SPI1->DR;
	temp = SPI1->SR;

	//while (!(SPI1->SR & SPI_SR_RXNE)) {}
	//uint8_t dummy = (uint8_t)SPI1->DR;
}


void spi1_receive(uint8_t *data, uint32_t size)
{
	while(size)
	{
		while(!(SPI1->SR & SPI_TXE)) {}
		//send dummy data
		SPI1->DR = 0;
		//wait for RXNE
		while(!(SPI1->SR & SPI_RXNE)){}

		//Read data
		*data++ = SPI1->DR;
		size--;
	}
}

void cs_enable(void)
{
	//cs PB0
	GPIOB->ODR &= ~(1U<<0);

}

void cs_disable(void)
{
	//cs   PB0
	GPIOB->ODR |= (1U<<0);

}
