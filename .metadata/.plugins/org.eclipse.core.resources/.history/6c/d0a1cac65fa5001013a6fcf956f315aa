#include "stm32C0xx.h"
#include <stdint.h>

#define GPIOBEN			(1U << 1)
#define APB_I2C1EN		(1U << 21)

#define I2C_CR1_PE			(1U << 0)
#define I2C_ISR_BUSY		(1U << 15)
#define I2C_CR2_START		(1U << 13)
// Assume 16 MHz clock
#define I2C_TIMING_100KHZ  0x00303D5B  // Typical value for 100 kHz @16MHz HSI

//SCL =  PB8 AF6
//SDA =  PB9 AF6
void I2C1_init(void)
{


	//clock for GPIOB
	RCC->IOPENR |= GPIOBEN;


	// set PB8 and 9 to alternate func
	GPIOB->MODER &= ~(1U<<16);
	GPIOB->MODER |= (1U<<17);

	GPIOB->OTYPER  &= ~(1U<<18);
	GPIOB->OTYPER  |= (1U<<19);

	// set Pint output type to open drain
	GPIOB->MODER |= (1U<<8);
	GPIOB->MODER |= (1U<<9);

	// Set output speed to Very High
	//GPIOB->OSPEEDR |= ((3U << (8 * 2)) | (3U << (9 * 2)));

	// enable pullup for both pins
	GPIOB->PUPDR  &= ~(1U<<17);
	GPIOB->PUPDR  |= (1U<<16);

	GPIOB->PUPDR  &= ~(1U<<19);
	GPIOB->PUPDR  |= (1U<<18);

	// set AF6
	GPIOB->AFR[1] &= ~((0xF << ((8 - 8) * 4)) | (0xF << ((9 - 8) * 4)));
	GPIOB->AFR[1] |=  ((6U << ((8 - 8) * 4)) | (6U << ((9 - 8) * 4)));


	//enable clock to APB
	RCC->APBENR1 |= APB_I2C1EN;



	// Disable I2C peripheral
	I2C1->CR1 &= ~I2C_CR1_PE;

	// Set timing (standard mode 100kHz, assuming 16 MHz clock)
	I2C1->TIMINGR = I2C_TIMING_100KHZ;

	// Re-enable peripheral
	I2C1->CR1 |= I2C_CR1_PE;




}


#define I2C_TIMEOUT         10000
#define I2C_ISR_TC			(1U << 6)


void I2C1_ReadByte(char saddr, char maddr, char* data)
{
	volatile int tmp;
	//--- 1. Make sure I2C1 is enabled
	//if (!(I2C1->CR1 & I2C_CR1_PE))
		//I2C1->CR1 |= I2C_CR1_PE;

	while(I2C1->ISR & I2C_ISR_BUSY){}


	// Slave address (7-bit) -> keep ADD10 at 0
	I2C1->CR2 |= (saddr << 1);
	//number of bytes is 1 to be received
	I2C1->CR2 |= (1U << 16);
	// Transfer direction -> master requests a read -> 1
	I2C1->CR2 |= (1U << 10);
	// Generate START
	I2C1->CR2 |= I2C_CR2_START;

	// Wait until transfer complete (TC)
	timeout = I2C_TIMEOUT;
	while (!(I2C1->ISR & I2C_ISR_TC))
	{
		if (--timeout == 0) return 0xFF;
	}


	//--- 3. Re-Start and read phase
	I2C1->CR2 |= (saddr << 1)
	// NBYTES = 1
	I2C1->CR2 |=(1U << 16);
	// RD_WRN = 1 (read)
	I2C1->CR2 |=I2C_CR2_RD_WRN;
	// Generate (re)START
	I2C1->CR2 |=I2C_CR2_START;
	// Auto generate STOP after last byte/
	I2C1->CR2 |=I2C_CR2_AUTOEND;

}
